import numpy as np
import random
import matplotlib.pyplot as plt

def lfsr(seed, polynomial, sequence_length):
    """
    Generates a sequence using a Linear Feedback Shift Register (LFSR).
    
    :param seed: Initial value of the LFSR (non-zero).
    :param polynomial: List of polynomial positions (e.g., [4, 1] for x^4 + x + 1).
    :param sequence_length: Length of the sequence to generate.
    :return: List of generated bits (0s and 1s).
    """
    state = seed  # Initialize the LFSR state with the seed
    sequence = []  # Store the generated sequence

    for _ in range(sequence_length):
        sequence.append(state & 1)  # Append the least significant bit (LSB) of the state
        feedback = 0  # Initialize feedback bit

        # Calculate feedback by XORing the bits at polynomial positions
        for i in polynomial:
            feedback ^= (state >> (i - 1)) & 1

        # Update the state: shift right and set the most significant bit (MSB) to feedback
        state = (state >> 1) | (feedback << (max(polynomial) - 1))

    return sequence

def print_lfsr_diagram(poly_name, polynomial):
    """Prints an ASCII diagram of the LFSR for the given polynomial."""
    max_bit = max(polynomial)
    diagram = ""
    
    diagram += "+----+    " * max_bit + "\n"
    diagram += "| D0 | -> " + " -> ".join([f"| D{i} |" for i in range(1, max_bit)]) + " -> (Output Bit)\n"
    diagram += "+----+    " * max_bit + "\n"
    
    feedback_positions = "   |    " * max_bit + "\n"
    feedback_lines = ""
    for i in sorted(polynomial):
        feedback_lines += "   |" + "      " * (i - 1) + "------" + " " * (6 * (max_bit - i)) + "\n"
    feedback_lines += "       Feedback via XOR\n"
    
    print(f"LFSR Diagram for {poly_name}:")
    print(diagram + feedback_positions + feedback_lines)

def analyze_sequences(polynomials, initial_value, sequence_length):
    """
    Analyzes sequences generated by LFSRs for given polynomials.
    
    :param polynomials: Dictionary of polynomial names and their positions.
    :param initial_value: Initial value for the LFSR.
    :param sequence_length: Length of the sequence to generate.
    """
    for poly_name, poly_positions in polynomials.items():
        sequence = lfsr(initial_value, poly_positions, sequence_length)
        print(f"Sequence for {poly_name}: {sequence}")
        print(f"Length of sequence: {len(sequence)}")
        print(f"Sequence repeats every {len(sequence) // 3} bits (if maximum-length).\n")
        
        # Print the LFSR diagram
        print_lfsr_diagram(poly_name, poly_positions)
        print("\n" + "-" * 50 + "\n")

# Define the polynomials and their feedback positions
polynomials = {
    "x^4 + x + 1": [4, 1],  # Primitive polynomial
    "x^4 + x^2 + 1": [4, 2],  # Irreducible but not primitive
    "x^4 + x^3 + x^2 + x + 1": [4, 3, 2, 1]  # Reducible polynomial
}

# Initial value for the LFSR (must be non-zero)
initial_value = 0b1001  # Example: 9 in decimal (binary 1001)

# Sequence length is 3 times the maximum length for n=4 (2^4 - 1 = 15)
sequence_length = 3 * (2**4 - 1)  # 45 bits

# Analyze sequences for the given polynomials
analyze_sequences(polynomials, initial_value, sequence_length)
